plot(laliga.network, edge.arrow.size = .02,
vertex.frame.color = adjustcolor("#555555", alpha = .3),
edge.color = adjustcolor(edge.color, alpha.f = .7),
vertex.color = adjustcolor(vertex.color, alpha = .6),
vertex.label = V(laliga.network)$label,
vertex.label.color = "black",
vertex.label.cex = .35,
vertex.label.family = "Helvetica",
layout=layout_nicely(laliga.network)
)
legend(x = -.9, y = -1, label, pch = 21, cex = 0.5,
text.width = 0.2, col= adjustcolor(vertex.color, alpha.f = .4),
pt.bg = adjustcolor(colors, alpha = .6), pt.cex = 1, bty = "n", ncol = 5)
# Re-generate dataframes for both nodes and edges, now containing
# calculated network attributes
node_list <- get.data.frame(laliga.network, what = "vertices")
# Determine a community for each edge. If two nodes belong to the
# same community, label the edge with that community. If not,
# the edge community value is 'NA'
edge_list <- get.data.frame(laliga.network, what = "edges") %>%
inner_join(node_list %>% select(name, group.label), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, group.label), by = c("to" = "name")) %>%
mutate(group = as.factor(group.label.x))
# Create a character vector containing every node name
all_nodes <- sort(node_list$name)
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data <- edge_list %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
name_order <- (node_list %>% arrange(group.label))$name
# Reorder edge_list "from" and "to" factor levels based on
# this new name_order
plot_data <- edge_list %>% mutate(
to = factor(to, levels = name_order),
from = factor(from, levels = name_order))
laliga.adjacency <- ggplot(plot_data, aes(x = from, y = to, fill = group)) +
geom_raster() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
xlab(NULL) + ylab(NULL) +
scale_fill_manual(values = colors[c(-1, -10, -12)],
labels = leagues[c(-1, -10, -12)],
name = "Leagues") +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_blank(),
axis.text.y = element_blank(),
# Force the plot into a square aspect ratio
aspect.ratio = 1
# Hide the legend (optional)
)
laliga.adjacency
bundes.links <- team_links %>%
filter(from %in% bundes.list | to %in% bundes.list)
bundes.nodes <- team_nodes %>%
filter(id %in% unique(c(as.character(bundes.links$from), as.character(bundes.links$to))))
bundes.network <- graph_from_data_frame(d = bundes.links, vertices = bundes.nodes, directed = TRUE)
V(bundes.network)$degree <- degree(bundes.network)
V(bundes.network)$closeness <- centralization.closeness(bundes.network)$res
V(bundes.network)$betweenness <- centralization.betweenness(bundes.network)$res
V(bundes.network)$eigen <- centralization.evcent(bundes.network)$vector
E(bundes.network)$width <- log(E(bundes.network)$weight + 1)
E(bundes.network)$width[E(bundes.network)$width < 0.5] <- 0.5
V(bundes.network)$size <- log(V(bundes.network)$value + 1) * 1.5
edge.color <- 1:length(E(bundes.network))
for(i in 1:nrow(bundes.nodes)){
index <- incident(bundes.network, V(bundes.network)[i], mode = 'out')
group_index <- bundes.nodes[i, "group.label"]
edge.color[index] <- colors[group_index]
}
vertex.color <- colors[V(bundes.network)$group.label]
plot(bundes.network, edge.arrow.size = .02,
vertex.frame.color = adjustcolor("#555555", alpha = .3),
edge.color = adjustcolor(edge.color, alpha.f = .7),
vertex.color = adjustcolor(vertex.color, alpha = .6),
vertex.label = V(bundes.network)$label,
vertex.label.color = "black",
vertex.label.cex = .35,
vertex.label.family = "Helvetica",
layout=layout_nicely(bundes.network)
)
legend(x = -.9, y = -1, label, pch = 21, cex = 0.5,
text.width = 0.2, col= adjustcolor(vertex.color, alpha.f = .4),
pt.bg = adjustcolor(colors, alpha = .6), pt.cex = 1, bty = "n", ncol = 5)
# Re-generate dataframes for both nodes and edges, now containing
# calculated network attributes
node_list <- get.data.frame(bundes.network, what = "vertices")
# Determine a community for each edge. If two nodes belong to the
# same community, label the edge with that community. If not,
# the edge community value is 'NA'
edge_list <- get.data.frame(bundes.network, what = "edges") %>%
inner_join(node_list %>% select(name, group.label), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, group.label), by = c("to" = "name")) %>%
mutate(group = as.factor(group.label.x))
edge_list <- data.frame(from = c(edge_list$from, edge_list$to),
to = c(edge_list$to, edge_list$from),
group.label.x = rep(edge_list$group.label.x, 2),
group.label.y = rep(edge_list$group.label.y, 2),
group = rep(edge_list$group, 2)
)
# Create a character vector containing every node name
all_nodes <- sort(node_list$name)
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data <- edge_list %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
name_order <- (node_list %>% arrange(group.label))$name
# Reorder edge_list "from" and "to" factor levels based on
# this new name_order
plot_data <- edge_list %>% mutate(
to = factor(to, levels = name_order),
from = factor(from, levels = name_order))
bundes.adjacency <- ggplot(plot_data, aes(x = from, y = to, fill = group)) +
geom_raster() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
xlab(NULL) + ylab(NULL) +
scale_fill_manual(values = colors[c(-1, -5, -8, -9, -10)],
labels = leagues[c(-1, -5, -8, -9, -10)],
name = "Leagues") +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_blank(),
axis.text.y = element_blank(),
# Force the plot into a square aspect ratio
aspect.ratio = 1
# Hide the legend (optional)
)
bundes.adjacency
seriea.links <- team_links %>%
filter(from %in% seriea.list | to %in% seriea.list)
seriea.nodes <- team_nodes %>%
filter(id %in% unique(c(as.character(seriea.links$from), as.character(seriea.links$to))))
seriea.network <- graph_from_data_frame(d = seriea.links, vertices = seriea.nodes, directed = TRUE)
V(seriea.network)$degree <- degree(seriea.network)
V(seriea.network)$closeness <- centralization.closeness(seriea.network)$res
V(seriea.network)$betweenness <- centralization.betweenness(seriea.network)$res
V(seriea.network)$eigen <- centralization.evcent(seriea.network)$vector
E(seriea.network)$width <- log(E(seriea.network)$weight + 1)
E(seriea.network)$width[E(seriea.network)$width < 0.5] <- 0.5
V(seriea.network)$size <- log(V(seriea.network)$value + 1) * 1.5
edge.color <- 1:length(E(seriea.network))
for(i in 1:nrow(seriea.nodes)){
index <- incident(seriea.network, V(seriea.network)[i], mode = 'out')
group_index <- seriea.nodes[i, "group.label"]
edge.color[index] <- colors[group_index]
}
vertex.color <- colors[V(seriea.network)$group.label]
plot(seriea.network, edge.arrow.size = .02,
vertex.frame.color = adjustcolor("#555555", alpha = .3),
edge.color = adjustcolor(edge.color, alpha.f = .7),
vertex.color = adjustcolor(vertex.color, alpha = .6),
vertex.label = V(seriea.network)$label,
vertex.label.color = "black",
vertex.label.cex = .35,
vertex.label.family = "Helvetica",
layout=layout_nicely(seriea.network)
)
legend(x = -.9, y = -1, label, pch = 21, cex = 0.5,
text.width = 0.2, col= adjustcolor(vertex.color, alpha.f = .4),
pt.bg = adjustcolor(colors, alpha = .6), pt.cex = 1, bty = "n", ncol = 5)
# Re-generate dataframes for both nodes and edges, now containing
# calculated network attributes
node_list <- get.data.frame(seriea.network, what = "vertices")
# Determine a community for each edge. If two nodes belong to the
# same community, label the edge with that community. If not,
# the edge community value is 'NA'
edge_list <- get.data.frame(seriea.network, what = "edges") %>%
inner_join(node_list %>% select(name, group.label), by = c("from" = "name")) %>%
inner_join(node_list %>% select(name, group.label), by = c("to" = "name")) %>%
mutate(group = as.factor(group.label.x))
# Create a character vector containing every node name
all_nodes <- sort(node_list$name)
# Adjust the 'to' and 'from' factor levels so they are equal
# to this complete list of node names
plot_data <- edge_list %>% mutate(
to = factor(to, levels = all_nodes),
from = factor(from, levels = all_nodes))
name_order <- (node_list %>% arrange(group.label))$name
# Reorder edge_list "from" and "to" factor levels based on
# this new name_order
plot_data <- edge_list %>% mutate(
to = factor(to, levels = name_order),
from = factor(from, levels = name_order))
seriea.adjacency <- ggplot(plot_data, aes(x = from, y = to, fill = group)) +
geom_raster() +
# Because we need the x and y axis to display every node,
# not just the nodes that have connections to each other,
# make sure that ggplot does not drop unused factor levels
scale_x_discrete(drop = FALSE) +
scale_y_discrete(drop = FALSE) +
xlab(NULL) + ylab(NULL) +
scale_fill_manual(values = colors[c(-5, -10, -12)],
labels = leagues[c(-5, -10, -12)],
name = "Leagues") +
theme(
# Rotate the x-axis lables so they are legible
axis.text.x = element_blank(),
axis.text.y = element_blank(),
# Force the plot into a square aspect ratio
aspect.ratio = 1
# Hide the legend (optional)
)
seriea.adjacency
# Betweenness Centrality of Whole network
whole.between <- betweenness(network, weights = E(network)$weight, normalized = T)
whole.between <- sort(whole.between, decreasing = TRUE)
head(round(whole.between, 3), 10)
index <- as.numeric(gsub(x = names(head(whole.between, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
whole.eigen <- eigen_centrality(network, directed = TRUE)
whole.eigen <- sort(whole.eigen$vector, decreasing = TRUE)
head(round(whole.eigen, 3), 10)
index <- as.numeric(gsub(x = names(head(whole.eigen, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
whole.degree <- degree(network, mode = "total", normalized = TRUE)
whole.degree <- sort(whole.degree, decreasing = TRUE)
head(round(whole.degree, 3), 10)
index <- as.numeric(gsub(x = names(head(whole.degree, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
whole.in <- degree_distribution(network, cumulative = FALSE, mode = 'in')
whole.in <- data.frame(Degree = 0:(length(whole.in) - 1),
Proportion = whole.in)
whole1 <- ggplot(whole.in[-1, ], aes(x = Degree, y = Proportion)) +
geom_line() +
geom_point() +
scale_x_log10(breaks = 1:31,
labels = c(1, rep("", 8), 10, rep("", 9), 20, rep("", 9), 30, "")) +
scale_y_log10() +
stat_function(fun = function(x){(log(x^(-.66))) - 0.42}, color = 'red', size = 1.2) +
xlab(expression(k[In])) + ylab(expression(P(k[In])))
whole1
temp <- ggplot_build(whole1)$data[[3]]
(temp[10, 2] - temp[2, 2])/(temp[10, 1] - temp[2, 1])
whole.out <- degree_distribution(network, cumulative = FALSE, mode = 'out')
whole.out <- data.frame(Degree = 0:(length(whole.out) - 1),
Proportion = whole.out)
whole2 <- ggplot(whole.out[-1, ], aes(x = Degree, y = Proportion)) +
geom_line() +
geom_point() +
scale_x_log10(breaks = 1:31,
labels = c(1, rep("", 8), 10, rep("", 9), 20, rep("", 9), 30, "")) +
scale_y_log10() +
stat_function(fun = function(x){(log(x^(-.8))) - 0.5}, color = 'red', size = 1.2) +
xlab(expression(k[Out])) + ylab(expression(P(k[Out])))
whole2
temp <- ggplot_build(whole2)$data[[3]]
(temp[10, 2] - temp[2, 2])/(temp[10, 1] - temp[2, 1])
library(gridExtra)
# Betweenness Centrality of Whole network
epl.between <- betweenness(epl.network, normalized = TRUE)
epl.between <- sort(epl.between, decreasing = TRUE)
head(round(epl.between, 3), 10)
index <- as.numeric(gsub(x = names(head(epl.between, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
epl.eigen <- eigen_centrality(epl.network, directed = TRUE)
epl.eigen <- sort(epl.eigen$vector, decreasing = TRUE)
head(round(epl.eigen, 3), 10)
index <- as.numeric(gsub(x = names(head(epl.eigen, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
epl.degree <- degree(epl.network, mode = "total", normalized = TRUE)
epl.degree <- sort(epl.degree, decreasing = TRUE)
head(round(epl.degree, 3), 10)
index <- as.numeric(gsub(x = names(head(epl.degree, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
epl.dd <- degree_distribution(epl.network, cumulative = FALSE)
epl.dd <- data.frame(Degree = 0:(length(epl.dd) - 1),
Proportion = epl.dd)
epl.dd
ggplot(epl.dd[-1, ], aes(x = Degree, y = Proportion)) +
geom_point() +
geom_line() +
scale_x_log10() + scale_y_log10() + geom_smooth(method = "lm")
# Betweenness Centrality of Whole network
laliga.between <- betweenness(laliga.network, normalized = TRUE)
laliga.between <- sort(laliga.between, decreasing = TRUE)
head(round(laliga.between, 3), 10)
index <- as.numeric(gsub(x = names(head(laliga.between, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
laliga.eigen <- eigen_centrality(laliga.network, directed = TRUE, scale = TRUE)
laliga.eigen <- sort(laliga.eigen$vector, decreasing = TRUE)
head(round(laliga.eigen, 3), 10)
index <- as.numeric(gsub(x = names(head(laliga.eigen, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
laliga.degree <- degree(laliga.network, mode = "total", normalized = TRUE)
laliga.degree <- sort(laliga.degree, decreasing = TRUE)
head(round(laliga.degree, 3), 10)
index <- as.numeric(gsub(x = names(head(laliga.degree, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
laliga.dd <- degree_distribution(laliga.network)
laliga.dd <- data.frame(Degree = 0:(length(laliga.dd) - 1),
Proportion = laliga.dd)
laliga.dd
ggplot(laliga.dd[-1, ], aes(x = Degree, y = Proportion)) +
geom_point() +
geom_line() +
scale_x_log10() + scale_y_log10() + geom_smooth(method = "lm")
# Betweenness Centrality of Whole network
bundes.between <- betweenness(bundes.network, normalized = TRUE)
bundes.between <- sort(bundes.between, decreasing = TRUE)
head(round(bundes.between, 3), 10)
index <- as.numeric(gsub(x = names(head(bundes.between, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
bundes.eigen <- eigen_centrality(bundes.network, directed = TRUE, scale = TRUE)
bundes.eigen <- sort(bundes.eigen$vector, decreasing = TRUE)
head(round(bundes.eigen, 3), 10)
index <- as.numeric(gsub(x = names(head(bundes.eigen, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
bundes.degree <- degree(bundes.network, mode = "total", normalized = TRUE)
bundes.degree <- sort(bundes.degree, decreasing = TRUE)
head(round(bundes.degree, 3), 10)
index <- as.numeric(gsub(x = names(head(bundes.degree, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
bundes.dd <- degree_distribution(bundes.network)
bundes.dd <- data.frame(Degree = 0:(length(bundes.dd) - 1),
Proportion = bundes.dd)
bundes.dd
ggplot(bundes.dd[-1, ], aes(x = Degree, y = Proportion)) +
geom_point() +
geom_line() +
scale_x_log10() + scale_y_log10() + geom_smooth(method = "lm")
# Betweenness Centrality of Whole network
seriea.between <- betweenness(seriea.network, normalized = TRUE)
seriea.between <- sort(seriea.between, decreasing = TRUE)
head(round(seriea.between, 3), 10)
index <- as.numeric(gsub(x = names(head(seriea.between, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
seriea.eigen <- eigen_centrality(seriea.network, directed = TRUE, scale = TRUE)
seriea.eigen <- sort(seriea.eigen$vector, decreasing = TRUE)
head(round(seriea.eigen, 3), 10)
index <- as.numeric(gsub(x = names(head(seriea.eigen, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
seriea.degree <- degree(seriea.network, mode = "total", normalized = TRUE)
seriea.degree <- sort(seriea.degree, decreasing = TRUE)
head(round(seriea.degree, 3), 10)
index <- as.numeric(gsub(x = names(head(seriea.degree, 10)), pattern = "team", replacement = ""))
team_nodes[index, ]
seriea.dd <- degree_distribution(seriea.network)
seriea.dd <- data.frame(Degree = 0:(length(seriea.dd) - 1),
Proportion = seriea.dd)
seriea.dd
insert_minor <- function(major_labs, n_minor) {labs <-
c( sapply( major_labs, function(x) c(x, rep("", 4) ) ) )
labs[1:(length(labs)-n_minor)]}
ggplot(seriea.dd[-1, ], aes(x = Degree, y = Proportion)) +
geom_point() +
geom_line() +
scale_x_log10() + scale_y_log10() + geom_smooth(method = "lm")
networkInfo <- function(network){
numEdge <- length(E(network))
numNode <- length(V(network))
sumWeight <- round(sum(E(network)$weight), 2)
averageWeight <- round(sumWeight/numNode, 2)
cat("#Edge:", numEdge, "\n#Node:", numNode, "\nTotal Transfer Fee:", paste0(sumWeight, "m\nAverage Transfer Fee per Event: ", paste0(averageWeight, "m\n")))
}
networkInfo(epl.network)
networkInfo(laliga.network)
networkInfo(bundes.network)
networkInfo(seriea.network)
write_csv(team_links, "~/Desktop/team_links.csv")
write_csv(team_nodes, "~/Desktop/team_nodes.csv")
library(RJSONIO)
library(dplyr)
library(stringr)
library(readr)
json <- read_lines("~/Google Drive/log.txt")
head(json, 40)
index <- !(1:length(json) %% 15 == 1 | 1:length(json) %% 15 == 4 |  1:length(json) %% 15 == 5 | 1:length(json) %% 15 == 6 | 1:length(json) %% 15 == 7 | 1:length(json) %% 15 == 8 | 1:length(json) %% 15 == 12)
json <- json[index]
head(json, 40)
clean_json <- json %>%
str_replace("ObjectId\\(", "") %>%
str_replace("ISODate\\(", "") %>%
str_replace("\\)", "") %>%
str_replace("    ", "") %>%
str_replace(" :", ":") %>%
str_replace("\\}", "\\}\n")
head(clean_json, 40)
write(clean_json, "~/Google Drive/clean_log.json")
test <- paste(clean_json, collapse = " ")
write(test, "~/Google Drive/test.txt")
going_data <- jsonlite::stream_in(file("~/Google Drive/test.txt"))
head(going_data)
library(readr)
write_csv(going_data, "~/Desktop/Baek.csv")
credit <- read.csv("~/Google Drive/ML Lecture/8 Tree Based/credit.csv")
summary(credit)
# install.packages(c("rpart", "rpart.plot"))
library(caret)
library(rpart)
library(rpart.plot)
# CART Algorithm
set.seed(123)
trainIdx <- sample(1:nrow(credit), size = nrow(credit) * 0.7)
trainCredit <- credit[trainIdx, ]
testCredit <- credit[-trainIdx, ]
creditTree <- rpart(default ~ ., data = trainCredit, method = "class")
creditTree
rpart.plot(creditTree)
rpart.plot(creditTree)
?rpart.plot
predictCredit <- predict(creditTree, testCredit, type = "class")
predictCredit <- predict(creditTree, testCredit, type = "class")
confusionMatrix(predictCredit, testCredit$default)
install.packages(c("randomForest", "ranger"))
library(randomForest)
set.seed(1234)
RF_Credit <- randomForest(default ~ ., data = trainCredit, importance = TRUE, replace = TRUE, proximity = TRUE, mtry = 4)
RF_Credit
varImpPlot(RF_Credit)
pred_RF_Credit <- predict(RF_Credit, testCredit)
pred_RF_Credit <- predict(RF_Credit, testCredit)
confusionMatrix(pred_RF_Credit, testCredit$default)
head(pred_RF_Credit)
confusionMatrix(pred_RF_Credit, testCredit$default)
library(ranger)
set.seed(1234)
RF_Credit2 <- ranger(default ~ ., data = trainCredit,
num.trees = 2000, importance = "impurity", replace = TRUE, write.forest = TRUE)
RF_Credit2
pred_RF_Credit <- predict(RF_Credit2, testCredit)
pred_RF_Credit
pred_RF_Credit$predictions
confusionMatrix(pred_RF_Credit$predictions, testCredit$default)
# install.packages("xgboost")
library(xgboost)
doMC::registerDoMC(4)
str(trainCredit)
trainLabel <- as.numeric(trainCredit$default) - 1
testLabel <- as.numeric(testCredit$default) - 1
trainMat <- model.matrix(default ~ ., data = trainCredit)[, -1]
testMat <- model.matrix(default ~ ., data = testCredit)[, -1]
View(trainMat)
trainMat <- model.matrix(default ~ ., data = trainCredit)[, -1]
testMat <- model.matrix(default ~ ., data = testCredit)[, -1]
credit_xgboost <- xgboost(data = trainMat,
label = trainLabel,
max.depth = 6,
eta = 0.3,
subsample = 1,
nrounds = 10,
objective = "binary:logistic",
eval_metric = "error"
)
xgb_pred <- predict(credit_xgboost, testMat)
head(xgb_pred)
xgb_pred <- ifelse(xgb_pred > 0.5, 1, 0)
confusionMatrix(xgb_pred, testCredit$default)
confusionMatrix(xgb_pred, testLabel)
set.seed(1234)
credit_xgboost <- xgboost(data = trainMat,
label = trainLabel,
max.depth = 6,
eta = 0.3,
subsample = 1,
nrounds = 10,
objective = "binary:logistic",
eval_metric = "error"
)
xgb_pred <- predict(credit_xgboost, testMat)
xgb_pred <- ifelse(xgb_pred > 0.5, 1, 0)
confusionMatrix(xgb_pred, testLabel)
library(caret)
cv.ctrl <- trainControl(method = "repeatedcv", number = 5, allowParallel = TRUE)
xgb.grid <- expand.grid(nrounds = seq(10, 30, by = 5),
eta = c(0.1, 0.3, 0.5),
max_depth = c(3, 5, 7),
gamma = 0,
colsample_bytree = c(0.8, 0.9, 1),
min_child_weight = c(0.8, 0.9, 1),
subsample = 1
)
head(xgb.grid)
set.seed(1234)
xgb_tune <- train(trainMat, factor(trainLabel),
method = "xgbTree", trControl = cv.ctrl,
tuneGrid = xgb.grid, verbose = TRUE,
metric = "error", nthread = 4)
xgb_tune$bestTune
xgb_tune$bestTune
credit_xgboost2 <- xgboost(data = trainMat,
label = trainLabel,
nrounds = 20,
max_depth = 3,
eta = 0.5,
gamma = 0,
colsample_bytree = 0.8,
min_child_weight = 0.8,
subsample = 1,
objective = "binary:logistic",
eval_metric = "error")
xgb_pred2 <- predict(credit_xgboost2, testMat)
xgb_pred2 <- ifelse(xgb_pred2 > 0.5, 1, 0)
confusionMatrix(xgb_pred2, testLabel)
confusionMatrix(xgb_pred, testLabel)
xgb_tune$bestTune
markdown("2016-12-27-domingos2012.Rmd", "machine_learning")
markdown("2016-12-27-domingos2012.Rmd", "machine_learning")
markdown("2016-12-27-domingos2012.Rmd", "machine_learning")
markdown("2016-12-27-domingos2012.Rmd", "machine_learning")
markdown("2016-12-27-domingos2012.Rmd", "machine_learning")
markdown("2016-12-27-domingos2012.Rmd", "machine_learning")
markdown("2016-12-27-domingos2012.Rmd", "machine_learning")
markdown("2016-12-27-domingos2012.Rmd", "machine_learning")
